
信道提供一种机制使两个并发执行的函数同步执行，并通过传递具体元素类型的值来通信。 未初始化的信道值为 nil。

    信道类型 = ( "chan" [ "<-" ] | "<-" "chan" ) 元素类型 .
<- 操作符指定信道的 方向，发送 或 接收。 若没有给定方向，那么该信道就是 双向的。 信道可通过类型转换 或 赋值被强制为只发送或只接收。

    chan T          // 可以被用来发送和接收类型T的值
    chan<- float64  // 只能被用来发送浮点数
    <-chan int      // 只能被用来接收整数
    <- 操作符结合最左边的 chan 可能的方式：

    chan<- chan int    // 等价于 chan<- (chan int)
    chan<- <-chan int  // 等价于 chan<- (<-chan int)
    <-chan <-chan int  // 等价于 <-chan (<-chan int)
    chan (<-chan int)
一个新的，已初始化的信道值可使用内建函数 make 创建， 它接受信道类型和一个可选的容量作为实参：

    make(chan int, 100)
容量根据元素的数量设置信道中缓存的大小。若容量大于零，则信道是异步的： 若缓存未满（发送）或非空（接收），则通信操作无阻塞成功，且元素在发送序列中被接收。 若容量为零或无，则只有当发送者和接收者都做好准备时通信才会成功。 nil 信道永远不会准备好通信。

信道可通过内建函数close关闭； 接收操作符的多值赋值形式可测试信道是否关闭。

# 接收操作符

对于信道类型的操作数 ch，接收操作符 <-ch 的值即为从信道 ch 接收的值。该信道的方向必须允许接收操作， 且该接收操作的类型即为该信道的元素类型。该值前的表达式块是有效的。 从 nil 信道接收将永远阻塞。从已关闭的信道接收将总是成功， 它会立刻返回其元素类型的零值

    v1 := <-ch
    v2 = <-ch
    f(<-ch)
    <-strobe  // 在时钟脉冲和丢弃接收值之前等待
接收表达式以

    x, ok = <-ch
    x, ok := <-ch
    var x, ok = <-ch
的形式用于赋值或初始化将产生一个类型为 bool 的附加结果，来报告通信是否成功。 若接收的值由一次成功向信道发送的操作发出的，则 ok 的值为 true； 若接收的值是由于信道被关闭或为空而产生的零值，则为 false。

