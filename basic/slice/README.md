# 创建切片、映射与信道

切片、映射与信道为无需使用 new 来间接额外分配的引用类型。内建函数 make 接受的类型 T 必须为切片、映射或信道类型，可选地跟着一个特殊类型的表达式列表。它返回类型为 T （而非 *T）的值。其内存根据初始值（§零值）片段的描述来初始化。

    调用             类型 T     结果

    make(T, n)       slice      类型为T，长度为n，容量为n的切片
    make(T, n, m)    slice      类型为T，长度为n，容量为m的切片

    make(T)          map        类型为T的映射
    make(T, n)       map        类型为T，初始空间为n个元素的映射

    make(T)          channel    类型为T的同步信道
    make(T, n)       channel    类型为T，缓存大小为n的异步信道
用于指定大小的实参 n 与 m 必须为整数值。 常量大小的实参必须为非负值，且可表示为 int 类型的值。 若 n 和 m 已给定且为常量，则 n 必不大于 m。若 n 在运行时为负值或大于 m， 就会引发运行时恐慌。

    s := make([]int, 10, 100)       // len(s) == 10，cap(s) ==   100 的切片
    s := make([]int, 1e3)           // len(s) == cap(s) == 1000 的   切片
    s := make([]int, 1<<63)         // 非法：len(s) 不能表示为 int 类    型的值
    s := make([]int, 10, 0)         // 非法：len(s) > cap(s)
    c := make(chan int, 10)         // 缓存大小为10的信道
    m := make(map[string]int, 100)  // 初始空间为100个元素的映射

# 长度与容量

内建函数 len 与 cap 接受各种类型的实参并返回 int 类型的结果。 该实现保证其结果总符合 int 类型。

    调用      实参类型         结果

    len(s)    string type      字符串的字节长度。
    		  [n]T, *[n]T      数组长度（== n）
    		  []T              切片长度
    		  map[K]T          映射长度（已定义键的数量）
    		  chan T           信道缓存中元素队列的长度
    
    cap(s)    [n]T, *[n]T      数组长度（== n）
    		  []T              切片容量
    		  chan T           信道缓存容量
切片的容量为其基本数组中已分配的空间元素的数量。以下关系在任何时候都成立：

    0 <= len(s) <= cap(s)
nil 切片、映射或信道的长度为0。nil 切片和信道的容量为0。

若 s 为字符串常量，则表达式 len(s) 即为 常量。 若 s 的类型为数组或数组指针，且表达式 s 不包含信道接收 或函数调用，则表达式 len(s) 与 cap(s) 即为常量，在这种用情况下， s 不会被求值。否则，len 与 cap 的调用不为常量，且 s 会被求值。

# 追加与复制切片

内建函数 append 与 copy 协助一般的切片操作。对于这两个函数， 无论其内存引用是否与其实参重复，其结果都是独立的。

变参函数 append 追加零个或更多值 x 至 类型为 S 的s，它必须为切片类型，且返回类型为 S 的结果切片， 值 x 被传至类型为 ...T 的形参，其中 T 为 S 的元素类型，且其各自的形参传递规则均适用。 作为一个特例，append 也接受第一个实参可赋予类型 []byte， 且第二个字符串类型的实参后跟 ...。此形式追加字符串类型的字节。

    append(s S, x ...T) S  // T是类型为S的元素
若 s 的容量不足够大以适应附加的值，append 会分配一个新的， 足够大的切片以适应现有切片元素与附加的值。因此，返回的切片可能涉及到不同的基本数组。

    s0 := []int{0, 0}
    s1 := append(s0, 2)                 // 追加单个元素    s1 == []   int{0, 0, 2}
    s2 := append(s1, 3, 5, 7)           // 追加多个元素    s2 == []   int{0, 0, 2, 3, 5, 7}
    s3 := append(s2, s0...)             // 追加一个切片    s3 == []   int{0, 0, 2, 3, 5, 7, 0, 0}
    s4 := append(s3[3:6], s3[2:]...)    // 追加重复切片    s4 == []   int{3, 5, 7, 2, 3, 5, 7, 0, 0}

    var t []interface{}
    t = append(t, 42, 3.1415, "foo")                        t ==    []interface{}{42, 3.1415, "foo"}

    var b []byte
    b = append(b, "bar"...)             // 追加字符串常量  b == []byte{'b', 'a', 'r' }

函数 copy 将切片元素从来源 src 复制到目标 dst 并返回复制的元素数量。两个实参必须都拥有相同的元素类型 T，且必须都可赋予类型为 []T 的切片。 被复制的元素数量为 len(src) 与 len(dst) 中最小的那个。 作为一个特例，copy 也接受一个可赋予类型 []byte 的目标实参以及一个字符串类型的来源实参。此形式从该字符串中复制字节到该字节切片。

    copy(dst, src []T) int
    copy(dst []byte, src string) int
例如：

    var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}
    var s = make([]int, 6)
    var b = make([]byte, 5)
    n1 := copy(s, a[0:])            // n1 == 6, s == []int{0, 1,    2, 3, 4, 5}
    n2 := copy(s, s[2:])            // n2 == 4, s == []int{2, 3,    4, 5, 4, 5}
    n3 := copy(b, "Hello, World!")  // n3 == 5, b == []byte("Hello")